---
import TestComponent from './TestComponent.astro';
import SlotWrapper from './SlotWrapper.astro';

export interface Props {
	level: number;
	maxLevel: number;
	componentData: {
		title: string;
		count: number;
		isActive: boolean;
	};
}

const { level, maxLevel, componentData } = Astro.props;
const { title, count, isActive } = componentData;

// Generate data for nested levels
const nestedTitle = `${title} - Level ${level}`;
const nestedCount = count + (level * 10);
const shouldNest = level < maxLevel;
---

<div class={`nested-container level-${level}`} data-level={level}>
	<SlotWrapper title={`Container Level ${level}`}>
		<Fragment slot="header">
			<div class="level-indicator">
				<span class="level-badge">Level {level}</span>
				<span class="depth-indicator">
					{Array.from({ length: level }, (_, i) => (
						<span class="depth-dot" key={i}></span>
					))}
				</span>
			</div>
		</Fragment>
		
		<TestComponent 
			title={nestedTitle}
			count={nestedCount}
			isActive={isActive}
		>
			{shouldNest && (
				<div class="nested-content">
					<p class="nesting-info">
						Nesting level {level} of {maxLevel}
					</p>
					
					<!-- Recursive nesting -->
					<NestedContainer 
						level={level + 1}
						maxLevel={maxLevel}
						componentData={{
							title: componentData.title,
							count: componentData.count,
							isActive: !componentData.isActive // Alternate active state
						}}
					/>
					
					<!-- Additional components at this level -->
					{level < 3 && (
						<div class="sibling-components">
							<TestComponent 
								title={`Sibling A - Level ${level}`}
								count={nestedCount + 100}
								isActive={true}
							/>
							<TestComponent 
								title={`Sibling B - Level ${level}`}
								count={nestedCount + 200}
								isActive={false}
							/>
						</div>
					)}
				</div>
			)}
			
			{!shouldNest && (
				<div class="terminal-content">
					<p class="terminal-message">
						ðŸŽ¯ Reached maximum nesting depth: {maxLevel}
					</p>
					<div class="terminal-stats">
						<p>Total levels traversed: {level}</p>
						<p>Final count value: {nestedCount}</p>
						<p>Component active: {isActive ? 'Yes' : 'No'}</p>
					</div>
				</div>
			)}
		</TestComponent>
		
		<Fragment slot="footer">
			<div class="level-footer">
				<small>Level {level} container footer</small>
				{shouldNest && (
					<small class="nesting-status">
						Will nest {maxLevel - level} more level{maxLevel - level !== 1 ? 's' : ''}
					</small>
				)}
			</div>
		</Fragment>
	</SlotWrapper>
</div>

<style>
	.nested-container {
		margin: 0.5rem 0;
		position: relative;
	}
	
	.level-1 {
		border-left: 4px solid #e74c3c;
	}
	
	.level-2 {
		border-left: 4px solid #f39c12;
	}
	
	.level-3 {
		border-left: 4px solid #f1c40f;
	}
	
	.level-4 {
		border-left: 4px solid #2ecc71;
	}
	
	.level-indicator {
		display: flex;
		align-items: center;
		justify-content: space-between;
		margin-bottom: 0.5rem;
	}
	
	.level-badge {
		background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
		color: white;
		padding: 0.25rem 0.75rem;
		border-radius: 20px;
		font-size: 0.8rem;
		font-weight: bold;
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
	
	.depth-indicator {
		display: flex;
		gap: 0.25rem;
		align-items: center;
	}
	
	.depth-dot {
		width: 8px;
		height: 8px;
		border-radius: 50%;
		background: linear-gradient(45deg, #3498db, #2ecc71);
		display: inline-block;
		box-shadow: 0 2px 4px rgba(0,0,0,0.1);
	}
	
	.nested-content {
		background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
		padding: 1rem;
		border-radius: 8px;
		margin: 0.5rem 0;
		border: 1px solid #bdc3c7;
	}
	
	.nesting-info {
		font-style: italic;
		color: #7f8c8d;
		margin: 0 0 1rem 0;
		text-align: center;
		font-size: 0.9rem;
	}
	
	.sibling-components {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 1rem;
		margin-top: 1rem;
		padding: 1rem;
		background-color: rgba(255, 255, 255, 0.7);
		border-radius: 6px;
		border: 1px dashed #95a5a6;
	}
	
	.terminal-content {
		background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
		color: white;
		padding: 1.5rem;
		border-radius: 8px;
		text-align: center;
		margin: 0.5rem 0;
	}
	
	.terminal-message {
		font-size: 1.1rem;
		font-weight: bold;
		margin: 0 0 1rem 0;
	}
	
	.terminal-stats {
		background-color: rgba(255, 255, 255, 0.1);
		padding: 1rem;
		border-radius: 6px;
		margin-top: 1rem;
	}
	
	.terminal-stats p {
		margin: 0.25rem 0;
		font-size: 0.9rem;
	}
	
	.level-footer {
		display: flex;
		justify-content: space-between;
		align-items: center;
		font-size: 0.8rem;
		color: #7f8c8d;
		margin-top: 0.5rem;
	}
	
	.nesting-status {
		background-color: #ecf0f1;
		padding: 0.25rem 0.5rem;
		border-radius: 12px;
		color: #2c3e50;
	}
	
	/* Responsive adjustments */
	@media (max-width: 768px) {
		.sibling-components {
			grid-template-columns: 1fr;
		}
		
		.level-indicator {
			flex-direction: column;
			align-items: flex-start;
			gap: 0.5rem;
		}
		
		.level-footer {
			flex-direction: column;
			align-items: flex-start;
			gap: 0.25rem;
		}
	}
	
	/* Animation for nested content */
	.nested-content {
		animation: slideIn 0.3s ease-out;
	}
	
	@keyframes slideIn {
		from {
			opacity: 0;
			transform: translateY(-10px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}
</style>
